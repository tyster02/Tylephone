/*
 * ESP32 DAC Synthesizer - Rotary Menu Edition
 * 
 * Hardware Setup:
 * - 12 GPIO pins for keyboard (each with 10kΩ pull-DOWN resistor to GND, touched with 3.3V stylus)
 * - 1 Rotary encoder (CLK, DT, SW) for all control
 * - 1 Passive buzzer on GPIO25 (DAC1)
 * - 1 7-segment display (common cathode)
 * 
 * UI Flow:
 * - Rest mode: 3 horizontal lines, dial adjusts volume
 * - Click: Enter menu (Waveform → Octave → Choppiness)
 * - Turn dial: Scroll through menu screens
 * - Click on a screen: Enter that setting, turn dial to adjust
 * - Click again: Save and return to rest mode
 */

#include <driver/dac.h>

// ============== PIN DEFINITIONS ==============

// Keyboard pins (12 keys - one octave)
const int KEY_PINS[13] = {13, 12, 14, 27, 33, 32, 36, 15, 2, 4, 16, 17, 35};
// Note names: C, C#, D, D#, E, F, F#, G, G#, A, A#, B

// Rotary encoder pins
const int ENCODER_CLK = 18;
const int ENCODER_DT = 19;
const int ENCODER_SW = 21;

// 7-segment display pins (a, b, c, d, e, f, g)
// UPDATE THESE TO MATCH YOUR WIRING!
const int SEG_PINS[7] = {23, 22, 34, 26, 35, 5, 39};

// DAC output
#define DAC_PIN DAC_CHANNEL_1  // GPIO25

// ============== CONFIGURATION ==============

#define SAMPLES 256
#define RATCHET_BASE_HZ 8  // Base frequency for ratchet effect (adjustable)

// Chromatic scale frequencies for octave 4 (middle octave)
const float NOTE_FREQS_OCT4[13] = {
  261.63,  // C4
  277.18,  // C#4
  293.66,  // D4
  311.13,  // D#4/Eb (adjusted down from 311.13)
  329.63,  // E4
  349.23,  // F4
  370.00,  // F#4 (adjusted down from 369.99)
  392.00,  // G4
  415.00,  // G#4/Ab (adjusted down from 415.30)
  440.00,  // A4
  466.16,  // A#4/Bb (adjusted down from 466.16)
  493.88,  // B4
  523.25   // C5 (adjusted down from 523.25)
};

// Octave 3 (low octave) frequencies
const float NOTE_FREQS_OCT3[13] = {
  130.81,  // C3
  138.59,  // C#3
  146.83,  // D3
  155.56,  // D#3
  164.81,  // E3
  174.61,  // F3
  185.00,  // F#3
  196.00,  // G3
  207.65,  // G#3
  220.00,  // A3
  233.08,  // A#3
  246.94,  // B3
  261.63   // C4 (high C)
};

// ============== WAVEFORM DATA ==============

enum WaveType {
  SQUARE = 0,
  TRIANGLE = 1,
  SINE = 2
};

uint8_t squareWave[SAMPLES];
uint8_t triangleWave[SAMPLES];
uint8_t sineWave[SAMPLES];

// ============== UI STATE ==============

enum UIMode {
  REST,           // Normal playing mode - show volume
  MENU_BROWSE,    // Browsing menu screens (waveform/octave/choppiness)
  SETTING_ADJUST  // Adjusting a specific setting
};

enum MenuScreen {
  MENU_WAVEFORM = 0,
  MENU_OCTAVE = 1,
  MENU_CHOPPINESS = 2
};

UIMode currentMode = REST;
MenuScreen currentMenu = MENU_WAVEFORM;

// Standby animation state
unsigned long lastAnimationUpdate = 0;
int animationStep = 0;
int currentAnimation = 0;  // Which animation is playing (0-3)
const unsigned long ANIMATION_SPEED = 200;  // milliseconds per step

// ============== SYNTH STATE ==============
#define SAMPLE_RATE 44100  // Fixed audio rate

volatile uint32_t phaseAccumulator = 0;
volatile uint32_t phaseIncrement = 0;


volatile uint8_t *currentWaveform = squareWave;

volatile uint8_t volume = 192;  // 0-255, start at 50%

WaveType selectedWaveform = SQUARE;
bool isHighOctave = false;
int choppiness = 1;  // 1, 2, 4, or 8
int currentNote = -1;

// Ratchet effect variables
unsigned long lastRatchetToggle = 0;
bool ratchetOn = true;

// Encoder state
int lastEncoderCLK = HIGH;
int encoderValue = 50;  // Current encoder position (0-100 for volume, or menu index)
int lastButtonState = HIGH;
unsigned long lastButtonPress = 0;
const unsigned long buttonDebounce = 200;

// Timer
hw_timer_t *timer = NULL;

// ============== 7-SEGMENT PATTERNS (4-segment top loop only) ==============
// Using segments: a (top), b (top-right), f (top-left), d (bottom)

// Volume patterns - fill circle: off → top → right → bottom → left (0-4 segments)
const byte VOLUME_PATTERNS[5] = {
  0b00000000,  // Empty (0%)
  0b00000001,  // a (top)
  0b00000011,  // a, b (top, right)
  0b00001011,  // a, b, d (top, right, bottom)
  0b00101011   // a, b, d, f (all 4 - full circle)
};

// Menu screen patterns
const byte PATTERN_MENU_CHOPPINESS = 0b00100010;  // Left and right (f, b)
const byte PATTERN_MENU_WAVEFORM = 0b00000011;    // Top and right (a, b)
const byte PATTERN_MENU_OCTAVE = 0b00001001;      // Top and bottom (a, d)

// Waveform option patterns
const byte PATTERN_WAVE_SQUARE = 0b00100011;   // Left, top, bottom (f, a, d)
const byte PATTERN_WAVE_SINE = 0b00101011;     // All 4 segments (f, a, b, d)
const byte PATTERN_WAVE_TRIANGLE = 0b00000011; // Top and right (a, b)

// Octave option patterns
const byte PATTERN_OCTAVE_LOW = 0b00001000;    // Bottom (d)
const byte PATTERN_OCTAVE_HIGH = 0b00000001;   // Top (a)

// Choppiness patterns - fill in order: left, right, top, bottom
const byte PATTERN_CHOP_1 = 0b00100000;  // Left (f)
const byte PATTERN_CHOP_2 = 0b00100010;  // Left + right (f, b)
const byte PATTERN_CHOP_4 = 0b00100011;  // Left, right, top (f, b, a)
const byte PATTERN_CHOP_8 = 0b00101011;  // All 4 (f, b, a, d)

// ============== TIMER INTERRUPT ==============

void IRAM_ATTR onTimer() {

  // --- Ratchet effect ---
  if (choppiness > 1) {
    static uint32_t ratchetCounter = 0;
    uint32_t ratchetPeriod = SAMPLE_RATE / (RATCHET_BASE_HZ * (choppiness / 2));

    ratchetCounter++;
    if (ratchetCounter >= ratchetPeriod) {
      ratchetOn = !ratchetOn;
      ratchetCounter = 0;
    }
  } else {
    ratchetOn = true;
  }

  if (phaseIncrement == 0 || !ratchetOn) {
    dac_output_voltage(DAC_PIN, 0);
    return;
  }

  // --- DDS Core ---
  phaseAccumulator += phaseIncrement;

  uint8_t index = phaseAccumulator >> 24;  // top 8 bits (256 samples)

  uint8_t sample = currentWaveform[index];

  uint8_t scaledValue = (sample * volume) / 255;

  dac_output_voltage(DAC_PIN, scaledValue);
}

// ============== SETUP ==============

void setup() {
  Serial.begin(115200);
  Serial.println("\n=== ESP32 DAC Synthesizer - Menu Edition ===");
  
// Initialize keyboard pins
for (int i = 0; i < 13; i++) {  // Changed from 12 to 13
  pinMode(KEY_PINS[i], INPUT);
}
  
  // Initialize encoder
  pinMode(ENCODER_CLK, INPUT);
  pinMode(ENCODER_DT, INPUT);
  pinMode(ENCODER_SW, INPUT_PULLUP);
  
  // Initialize 7-segment display
  for (int i = 0; i < 7; i++) {
    pinMode(SEG_PINS[i], OUTPUT);
  }
  
  // Initialize DAC
  dac_output_enable(DAC_PIN);
  
  // Generate waveforms
  generateWaveforms();
  
  timer = timerBegin(SAMPLE_RATE);   // 44.1kHz timer
  timerAttachInterrupt(timer, &onTimer);
  timerAlarm(timer, 1, true, 0);     // fire every tick

  
  // Show rest mode
  updateDisplay();
  
  Serial.println("Synthesizer ready! Turn dial for volume, click to enter menu.");
}

// ============== MAIN LOOP ==============

void loop() {
  // Update standby animation if in REST mode and not adjusting volume
  if (currentMode == REST) {
    updateStandbyAnimation();
  }
  
  // Read encoder rotation
  readEncoder();
  
  // Read encoder button
  readEncoderButton();
  
  // Scan keyboard
  scanKeyboard();
  
  delay(1);
}

// ============== WAVEFORM GENERATION ==============

void generateWaveforms() {
  // Sine wave - boosted to 90% of max amplitude for better volume
  for (int i = 0; i < SAMPLES; i++) {
    sineWave[i] = (uint8_t)(127.5 + 115.0 * sin(2.0 * PI * i / SAMPLES));
  }
  
  // Triangle wave - boosted to full amplitude for better volume
  for (int i = 0; i < SAMPLES; i++) {
    if (i < SAMPLES / 2) {
      triangleWave[i] = (uint8_t)(i * 512 / SAMPLES);
    } else {
      triangleWave[i] = (uint8_t)(255 - ((i - SAMPLES / 2) * 512 / SAMPLES));
    }
  }
  
  // Square wave - already at full amplitude
  for (int i = 0; i < SAMPLES; i++) {
    squareWave[i] = (i < SAMPLES / 2) ? 255 : 0;
  }
}

// ============== FREQUENCY CONTROL ==============

void setFrequency(float freq) {
  if (freq <= 0) {
    phaseIncrement = 0;
    return;
  }

  phaseIncrement = (uint32_t)((freq * 4294967296.0) / SAMPLE_RATE);
}


void playNote(int noteIndex) {
  if (noteIndex < 0 || noteIndex >= 13) {
    stopNote();
    return;
  }
  
  // Use the appropriate octave frequency table
  float freq = isHighOctave ? NOTE_FREQS_OCT4[noteIndex] : NOTE_FREQS_OCT3[noteIndex];
  
  setFrequency(freq);
  currentNote = noteIndex;
  lastRatchetToggle = millis();  // Reset ratchet timing
  ratchetOn = true;
}

void stopNote() {
  phaseIncrement = 0;
  currentNote = -1;
  dac_output_voltage(DAC_PIN, 0);
}


// ============== KEYBOARD SCANNING ==============

void scanKeyboard() {
  bool anyKeyPressed = false;
  
  for (int i = 0; i < 13; i++) {
    if (digitalRead(KEY_PINS[i]) == HIGH) {
      if (currentNote != i) {
        Serial.print("Key pressed: ");
        Serial.print(i);
        Serial.print(" - Freq: ");
        Serial.println(isHighOctave ? NOTE_FREQS_OCT4[i] : NOTE_FREQS_OCT3[i]);
        playNote(i);
      }
      anyKeyPressed = true;
      break;
    }
  }
  
  if (!anyKeyPressed && currentNote != -1) {
    stopNote();
  }
}

// ============== ROTARY ENCODER ==============

void readEncoder() {
  int currentCLK = digitalRead(ENCODER_CLK);
  
  if (currentCLK != lastEncoderCLK && currentCLK == LOW) {
    // Swapped direction to fix backwards encoder
    int direction = (digitalRead(ENCODER_DT) == HIGH) ? -1 : 1;
    
    switch (currentMode) {
      case REST:
        // Adjust volume
        encoderValue += direction * 5;  // Change by 5% increments
        encoderValue = constrain(encoderValue, 0, 100);
        volume = (encoderValue * 255) / 100;
        lastAnimationUpdate = millis();  // Reset animation timer when user interacts
        Serial.println("Volume: " + String(encoderValue) + "%");
        break;
        
      case MENU_BROWSE:
        // Cycle through menu screens
        if (direction > 0) {
          currentMenu = (MenuScreen)((currentMenu + 1) % 3);
        } else {
          currentMenu = (MenuScreen)((currentMenu + 2) % 3);  // +2 is same as -1 mod 3
        }
        Serial.print("Menu: ");
        Serial.println(currentMenu == MENU_WAVEFORM ? "Waveform" : 
                      (currentMenu == MENU_OCTAVE ? "Octave" : "Choppiness"));
        break;
        
      case SETTING_ADJUST:
        adjustCurrentSetting(direction);
        break;
    }
    
    updateDisplay();
  }
  
  lastEncoderCLK = currentCLK;
}

void readEncoderButton() {
  int buttonState = digitalRead(ENCODER_SW);
  
  if (buttonState == LOW && lastButtonState == HIGH && 
      millis() - lastButtonPress > buttonDebounce) {
    
    handleButtonPress();
    lastButtonPress = millis();
  }
  
  lastButtonState = buttonState;
}

void handleButtonPress() {
  switch (currentMode) {
    case REST:
      // Enter menu
      currentMode = MENU_BROWSE;
      currentMenu = MENU_WAVEFORM;
      Serial.println("Entered menu");
      break;
      
    case MENU_BROWSE:
      // Enter setting adjustment
      currentMode = SETTING_ADJUST;
      Serial.println("Adjusting setting...");
      break;
      
    case SETTING_ADJUST:
      // Save and return to rest
      currentMode = REST;
      encoderValue = (volume * 100) / 255;  // Reset encoder to current volume
      Serial.println("Saved! Back to rest mode");
      break;
  }
  
  updateDisplay();
}

void adjustCurrentSetting(int direction) {
  switch (currentMenu) {
    case MENU_WAVEFORM:
      // Cycle through waveforms
      if (direction > 0) {
        selectedWaveform = (WaveType)((selectedWaveform + 1) % 3);
      } else {
        selectedWaveform = (WaveType)((selectedWaveform + 2) % 3);
      }
      
      // Update waveform pointer
      switch (selectedWaveform) {
        case SINE:
          currentWaveform = sineWave;
          Serial.println("Waveform: Sine");
          break;
        case SQUARE:
          currentWaveform = squareWave;
          Serial.println("Waveform: Square");
          break;
        case TRIANGLE:
          currentWaveform = triangleWave;
          Serial.println("Waveform: Triangle");
          break;
      }
      break;
      
    case MENU_OCTAVE:
      // Toggle octave
      isHighOctave = !isHighOctave;
      Serial.println(isHighOctave ? "Octave: High" : "Octave: Low");
      
      // Update current note if playing
      if (currentNote != -1) {
        playNote(currentNote);
      }
      break;
      
    case MENU_CHOPPINESS:
      // Cycle through choppiness: 1 → 2 → 4 → 8 → 1
      if (direction > 0) {
        choppiness = (choppiness >= 8) ? 1 : choppiness * 2;
      } else {
        choppiness = (choppiness <= 1) ? 8 : choppiness / 2;
      }
      Serial.println("Choppiness: " + String(choppiness));
      break;
  }
}

// ============== STANDBY ANIMATIONS ==============

void updateStandbyAnimation() {
  // Only animate if user hasn't interacted recently (3 seconds idle)
  unsigned long now = millis();
  if (now - lastAnimationUpdate < 3000) {
    return;  // Show volume instead
  }
  
  // Update animation step
  if (now - lastAnimationUpdate >= ANIMATION_SPEED) {
    animationStep++;
    
    // Switch to next animation after completing current one
    if (animationStep >= 8) {  // Most animations have 4-8 steps
      animationStep = 0;
      currentAnimation = random(0, 4);  // Pick random animation
    }
    
    lastAnimationUpdate = now;
    updateDisplay();
  }
}

byte getStandbyAnimationPattern() {
  switch (currentAnimation) {
    case 0:  // Animation 1: Single light looping (top → right → bottom → left)
      switch (animationStep % 4) {
        case 0: return 0b00000001;  // Top (a)
        case 1: return 0b00000010;  // Right (b)
        case 2: return 0b00001000;  // Bottom (d)
        case 3: return 0b00100000;  // Left (f)
      }
      break;
      
    case 1:  // Animation 2: Top+bottom then left+right alternating
      return (animationStep % 2 == 0) ? 0b00001001 : 0b00100010;
      
    case 2:  // Animation 3: Fill then deplete
      if (animationStep < 4) {
        // Fill: off → top → top+right → top+right+bottom → all
        switch (animationStep) {
          case 0: return 0b00000001;  // Top
          case 1: return 0b00000011;  // Top + right
          case 2: return 0b00001011;  // Top + right + bottom
          case 3: return 0b00101011;  // All 4
        }
      } else {
        // Deplete in reverse
        switch (animationStep - 4) {
          case 0: return 0b00001011;  // Remove left
          case 1: return 0b00000011;  // Remove bottom
          case 2: return 0b00000001;  // Remove right
          case 3: return 0b00000000;  // All off
        }
      }
      break;
      
    case 3:  // Animation 4: Light corners in order (top → right → bottom → left)
      switch (animationStep % 4) {
        case 0: return 0b00000001;  // Top
        case 1: return 0b00000010;  // Right
        case 2: return 0b00001000;  // Bottom
        case 3: return 0b00100000;  // Left
      }
      break;
  }
  
  return 0b00000000;  // Default: all off
}

// ============== 7-SEGMENT DISPLAY ==============

void updateDisplay() {
  byte pattern = 0;
  int volumeLevel;  // Declare outside switch to avoid jump error
  unsigned long now = millis();
  
  switch (currentMode) {
    case REST:
      // Show standby animation if idle for 3 seconds, otherwise show volume
      if (now - lastAnimationUpdate >= 3000) {
        pattern = getStandbyAnimationPattern();
      } else {
        // Show volume as filling circle (0-4 segments)
        volumeLevel = (encoderValue * 4) / 100;
        if (volumeLevel > 4) volumeLevel = 4;
        pattern = VOLUME_PATTERNS[volumeLevel];
      }
      break;
      
    case MENU_BROWSE:
      // Show which menu screen we're on
      switch (currentMenu) {
        case MENU_CHOPPINESS:
          pattern = PATTERN_MENU_CHOPPINESS;
          break;
        case MENU_WAVEFORM:
          pattern = PATTERN_MENU_WAVEFORM;
          break;
        case MENU_OCTAVE:
          pattern = PATTERN_MENU_OCTAVE;
          break;
      }
      break;
      
    case SETTING_ADJUST:
      // Show current setting value
      switch (currentMenu) {
        case MENU_WAVEFORM:
          switch (selectedWaveform) {
            case SINE:
              pattern = PATTERN_WAVE_SINE;
              break;
            case SQUARE:
              pattern = PATTERN_WAVE_SQUARE;
              break;
            case TRIANGLE:
              pattern = PATTERN_WAVE_TRIANGLE;
              break;
          }
          break;
          
        case MENU_OCTAVE:
          pattern = isHighOctave ? PATTERN_OCTAVE_HIGH : PATTERN_OCTAVE_LOW;
          break;
          
        case MENU_CHOPPINESS:
          switch (choppiness) {
            case 1:
              pattern = PATTERN_CHOP_1;
              break;
            case 2:
              pattern = PATTERN_CHOP_2;
              break;
            case 4:
              pattern = PATTERN_CHOP_4;
              break;
            case 8:              pattern = PATTERN_CHOP_8;
              break;
          }
          break;
      }
      break;
  }
  
  // Output to 7-segment display (only first 4 pins used for top loop)
  for (int i = 0; i < 7; i++) {
    digitalWrite(SEG_PINS[i], (pattern & (1 << i)) ? HIGH : LOW);
  }
}
